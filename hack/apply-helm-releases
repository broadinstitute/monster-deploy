#!/usr/bin/env bash
set -euo pipefail

declare -r SCRIPT_DIR=$(cd $(dirname ${0}) >/dev/null 2>&1 && pwd)
declare -r REPO_ROOT=$(cd $(dirname ${SCRIPT_DIR}) >/dev/null 2>&1 && pwd)

source ${SCRIPT_DIR}/common.sh

declare -r HELM_CHARTS_DIR=${REPO_ROOT}/templates/helm

#####
## Configure Helm in Docker
#####
function configure_helm () {
  local -r kubeconfig=$1 helm_dir=$2

  declare -ra helm=(
    docker run
    --rm -it
    # Configure the client to point at the cluster.
    -v ${kubeconfig}:/root/.kube/config:ro
    # Make sure it can auth with GKE.
    -v ${HOME}/.config/gcloud:/root/.config/gcloud:ro
    # Persist Helm config across container runs.
    -v ${helm_dir}/plugins:/root/.local/share/helm/plugins
    -v ${helm_dir}/config:/root/.config/helm
    -v ${helm_dir}/cache:/root/.cache/helm
    # Make our local charts available.
    -v ${HELM_CHARTS_DIR}:/charts
    ${HELM}
  )
  echo ${helm[@]}
}

#####
## Deploy the helm-operator and a bundle of release definitions into
## the command-center cluster for an environment.
#####
function run_command_center_release () {
  local -r kubeconfig=$1 env=$2 helm_dir=$3

  local -ra helm=($(configure_helm ${kubeconfig} ${helm_dir}))
  local -r bootstrap_secret=secret/dsde/monster/${env}/approle-monster-${env}
  local -r sql_instance_secret=secret/dsde/monster/${env}/command-center/cloudsql/instance

  ${helm[@]} dependency update /charts/command-center
  ${helm[@]} upgrade command-center /charts/command-center \
   --namespace fluxcd \
   --install \
   --set "env=${env}" \
   --set "cloudsql.name=$(vault read -field=name ${sql_instance_secret})" \
   --set "cloudsql.project=$(vault read -field=project ${sql_instance_secret})" \
   --set "cloudsql.region=$(vault read -field=region ${sql_instance_secret})" \
   --set "crd-operators.secretManager.roleId=$(vault read -field=role_id ${bootstrap_secret})" \
   --set "crd-operators.secretManager.secretId=$(vault read -field=secret_id ${bootstrap_secret})" \
   --set "argoNamespaces[0]=clinvar" \
   --set "argoNamespaces[1]=v2f"
}

#####
## Deploy the helm-operator and a bundle of release definitions into
## a processing-project cluster in an environment.
#####
function run_processing_release () {
  local -r kubeconfig=$1 env=$2 helm_dir=$3

  local -ra helm=($(configure_helm ${kubeconfig} ${helm_dir}))
  local -r bootstrap_secret=secret/dsde/monster/${env}/approle-monster-${env}

  ${helm[@]} dependency update /charts/crd-operators
  ${helm[@]} upgrade crd-operators /charts/crd-operators \
   --namespace fluxcd \
   --install \
   --set "secretManager.roleId=$(vault read -field=role_id ${bootstrap_secret})" \
   --set "secretManager.secretId=$(vault read -field=secret_id ${bootstrap_secret})"
}

#####
## Entrypoint to the script.
##
## Ensures all expected Helm charts are released to the
## command-center and processing clusters within a core
## Monster environment.
#####
function main () {
  # Check args.
  if [ $# -ne 1 ]; then
    1>&2 echo Usage: ${0} '<env>'
    exit 1
  fi

  # Make sure config exists.
  local -r env=$1
  local -r env_dir=${REPO_ROOT}/environments/${env}
  if [ ! -d ${env_dir} ]; then
    1>&2 echo Error: Invalid environment "'$1'"
    exit 1
  fi

  local -r config_dir=${env_dir}/.kubeconfig
  local -r processing_config_dir=${config_dir}/processing
  mkdir -p ${processing_config_dir}

  local -r helm_dir=${env_dir}/.helm
  mkdir -p ${helm_dir}

  # Pull the names of expected processing projects from Vault.
  local -ra project_names=($(get_processing_names ${env}))

  # Push releases to the command center.
  local -r center_config=${config_dir}/command-center
  get_command_center_config ${env} ${center_config}
  run_command_center_release ${center_config} ${env} ${helm_dir}

  # Push releases to processing projects.
  for project in ${project_names[@]}; do
    local -r project_config=${processing_config_dir}/${project}
    get_processing_config ${env} ${project} ${project_config}
    run_processing_release ${project_config} ${env} ${helm_dir}
  done
}

main ${@}
